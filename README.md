# LaColaRij

Want Linear.app speeds but still have to use Jira?
LaColaRij (JiraLocal backwards) is a local-first application for editing JIRA issues offline. It syncs with JIRA Cloud (Server planned for later), stores issues locally in IndexedDB, and allows editing even without network connectivity. Changes are synchronized when online, with manual conflict resolution.

The idea is that you self-host or locally run a LaColaRij instance. You then authenticate via API-Key with a Jira instance and download all the issues with a sync. Then work on issues and later sync back your changes.

**Live Demo:** https://localjira.petertissen.de/

## Table of Contents

- [Problem Description](#problem-description)
- [AI-Assisted Development](#ai-assisted-development)
- [Technologies and Architecture](#technologies-and-architecture)
- [Frontend Implementation](#frontend-implementation)
- [API Contract](#api-contract)
- [Backend Implementation](#backend-implementation)
- [Database Integration](#database-integration)
- [Containerization](#containerization)
- [Integration Testing](#integration-testing)
- [Deployment](#deployment)
- [CI/CD Pipeline](#cicd-pipeline)
- [Reproducibility](#reproducibility)

## Problem Description

### Core Problem
JIRA's web interface is slow, requires constant connectivity, and provides a suboptimal experience for developers who need quick access to their issues.

### Solution
LaColaRij provides:
- **Offline-first editing** - Work on issues without network connectivity
- **Background synchronization** - Changes sync automatically when online
- **Conflict resolution** - Manual resolution when remote changes conflict with local edits
- **Fast Kanban board** - Snappy drag-and-drop interface for status transitions
- **Full-text search** - Instant search across all locally stored issues

### Project Status
This is a **proof of concept**. Basic functionality with JIRA REST API v3 (Jira Cloud) is implemented. Compatibility with JIRA REST API v2 (Jira Server) is planned but not yet implemented.

## AI-Assisted Development

This project was developed as an exploration of LLM capabilities and the current LLM tool landscape. A significant portion of the code was generated by various LLMs.

**Tools used:**
- Anthropic Claude Code (Opus 4.5)
- Google Antigravity (Gemini 3 High)
- VSCode extensions (Cline, kilo.code)
- z.ai (GLM 4.6 and GLM 4.7)

**MCP Tools:** Context7 was enabled during some phases of the project for enhanced context management.

For detailed information on the AI-assisted development process, see [docs/llm_use/README.md](./docs/llm_use/README.md).

## Technologies and Architecture

### Technology Stack

| Layer | Technology |
|-------|------------|
| Frontend | React 18, TypeScript, Vite |
| Styling | Tailwind CSS, shadcn/ui components |
| State | Zustand (UI), Dexie (IndexedDB) |
| Backend | Python 3.10+, FastAPI, SQLAlchemy 2.0 |
| Database | SQLite (dev) / PostgreSQL (prod) |
| Testing | Vitest, Playwright, pytest |
| Containerization | Docker multi-stage, docker-compose |
| CI/CD | GitHub Actions |

### Architecture Overview

The initial plan was to build the entire project as a pure web app. However, the Jira Cloud API doesn't have the necessary CORS headers set to allow direct browser requests. Therefore, all Jira requests need to be relayed through a backend server. This also means your Jira API key is stored on the server (encrypted).

```
┌────────────────────────────────────────────────────────────────────────────┐
│                              Browser (Frontend)                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐│
│  │  React Views │──│ State Manager│──│  Sync Engine │──│ Storage Layer    ││
│  │  (List/Board)│  │ (Zustand)    │  │ (Background) │  │ (IndexedDB/Cache)││
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────────┘│
└─────────────────────────────────────────────|──────────────────────────────┘
                                              │ HTTP
┌─────────────────────────────────────────────|───────────────────────────────┐
│                            Backend (Python/FastAPI)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────────────────────────┐│
│  │ User Service │  │ Relay Service│──│ Mode Router (relay|demo)            ││
│  │ (Settings)   │  │ (CORS proxy) │  │   ├─ Real JIRA (forward requests)   ││
│  └──────────────┘  └──────────────┘  │   └─ Mock JIRA (local state)        ││
│                                      └─────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
```

For detailed architecture documentation, see [docs/architecture.md](./docs/architecture.md).

## Frontend Implementation

The frontend is a Single Page Application built with React 18, TypeScript, and Vite.

### Key Features
- **Issue List View** - Sortable, filterable list with virtual scrolling
- **Kanban Board** - Drag-and-drop status transitions with quick filters
- **Full-text Search** - Instant search across summary, description, and comments
- **Offline Support** - All data stored locally in IndexedDB via Dexie
- **Sync Status** - Visual indicators for pending changes and conflicts

### State Management
- **Zustand** for UI state (filters, selections, navigation)
- **Dexie** for persistent local storage (IndexedDB wrapper)
- **TanStack Query** for server state caching

### Testing
- **14 Vitest test files (247 tests)** covering components, services, stores, and utilities
- **18 Playwright E2E test files** covering full user flows

### Commands
```bash
cd frontend

# Install dependencies
npm install

# Development server
npm run dev

# Run unit tests
npm run test

# Run E2E tests (requires backend running)
npm run test:e2e

# Run E2E tests with browser visible
npm run test:e2e:headed
```

## API Contract

The backend implements an OpenAPI 3.0.3 specification available at [docs/api/openapi.yaml](./docs/api/openapi.yaml).

### Key Endpoints

| Category | Endpoints |
|----------|-----------|
| Authentication | `POST /api/auth/register`, `POST /api/auth/login`, `POST /api/auth/logout`, `GET /api/auth/me` |
| Connections | `GET/POST /api/users/connections`, `PUT/DELETE /api/users/connections/{id}` |
| JIRA Relay | `ANY /api/jira/{connection_id}/*` - proxies requests to JIRA |
| Health | `GET /health` |

### Authentication
All protected endpoints require JWT Bearer authentication:
```
Authorization: Bearer <your_token>
```

## Backend Implementation

The backend is built with Python 3.10+ and FastAPI.

### Module Structure
```
backend/app/
├── api/           # API routers (auth, users, relay)
├── core/          # Security (JWT, Argon2 password hashing)
├── models/        # SQLAlchemy models (User, JiraConnection)
├── services/      # Business logic (relay, mock_jira)
└── db/            # Database configuration and repositories
```

### Services
- **User Authentication** - JWT tokens with Argon2 password hashing
- **Relay Service** - CORS proxy for JIRA API requests with Basic Auth injection
- **Mock JIRA Service** - Local mock server for demo mode and testing

### Testing
- **4 pytest test files (82 tests)** covering repositories, security, and mock JIRA

### Commands
```bash
cd backend

# Install dependencies
uv sync --dev

# Run tests
uv run pytest

# Development server
uv run uvicorn app.main:app --reload --port 8080

# Linting
uv run ruff check .
uv run ruff format --check .
```

## Database Integration

### Backend Database
The backend uses SQLAlchemy 2.0 with async support:
- **SQLite** (default) - Simple file-based database for development and small deployments
- **PostgreSQL** - Production-ready for multi-user environments

The database stores user credentials and JIRA connection settings. API tokens are encrypted at rest.

### Frontend Storage
The frontend uses **IndexedDB via Dexie** to store:
- Issues and their metadata
- Comments
- Sync metadata and pending operations

This enables full offline functionality - the entire issue dataset is available locally.

For detailed database documentation, see [docs/Database.md](./docs/Database.md).

## Containerization

JiraLocal uses Docker multi-stage builds for optimized production images:
- **Frontend** - Built with Node.js, served via nginx
- **Backend** - Python application served via gunicorn

### Compose Configurations
- `docker-compose.sqlite.yml` - SQLite backend (simple, single-file)
- `docker-compose.postgres.yml` - PostgreSQL backend (production-ready)

### Data Persistence
- SQLite data stored in Docker volumes
- PostgreSQL data stored in dedicated database volume

## Integration Testing

End-to-end tests run the full stack with the mock JIRA backend to verify complete user flows.

### Test Coverage

| Area | Tests |
|------|-------|
| Authentication | Login, registration, session management |
| Sync | Initial sync, push/pull, conflict resolution, offline editing |
| Issues | List view, detail view, inline editing, comments, create |
| Board | Rendering, drag-and-drop, quick filters |
| Search | Full-text search |
| Settings | Connection management |

### Commands
```bash
cd frontend

# Run E2E tests (headless)
npm run test:e2e

# Run E2E tests with browser visible
npm run test:e2e:headed

# Run specific test file
npm run test:e2e -- e2e/tests/sync/conflict-resolution.spec.ts
```

## Deployment

### Live Instance
**URL:** https://localjira.petertissen.de/

Deployed to OCI (Oracle Cloud Infrastructure) with auto-deployment on push to main (after tests pass).

### Docker Deployment

#### Prerequisites
- Docker and Docker Compose installed
- Port 6555 available (configurable via `HOST_PORT`)

#### Quick Start (Recommended)

**macOS / Linux:**
```bash
cd deployment
./deploy.sh
```

**Windows:**
```batch
cd deployment
.\deploy.bat
```

The scripts will:
- Check that Docker is installed
- Create `.env.docker` from template
- Generate secure `SECRET_KEY` and `ENCRYPTION_KEY` automatically
- Start containers with SQLite

Access the application at http://localhost:6555

#### Manual Setup
For manual deployment instructions, see [docs/deployment_manual.md](./docs/deployment_manual.md).

## CI/CD Pipeline

GitHub Actions workflow at `.github/workflows/ci.yml`:

### Triggers
- **Push** to `main` branch
- **Pull requests** to `main` branch

### Pipeline Stages

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────┐
│ Lint            │     │ Test             │     │ Deploy      │
│ ├─ Backend      │────▶│ ├─ Frontend Unit │────▶│ (main only) │
│ └─ Frontend     │     │ ├─ Frontend E2E  │     │             │
└─────────────────┘     │ └─ Backend pytest│     └─────────────┘
                        └──────────────────┘
```

All lint and test jobs must pass before deployment. Deployment only runs on pushes to `main`.

## Reproducibility

Complete instructions to build and run the project from scratch.

### Prerequisites
- Node.js 20+
- Python 3.10+
- uv (Python package manager)
- Docker and Docker Compose (for containerized deployment)

### Quick Start

```bash
# Clone the repository
git clone https://github.com/yourusername/jiralocal.git
cd jiralocal

# Backend setup and test
cd backend
uv sync --dev
uv run pytest

# Frontend setup and test
cd ../frontend
npm install
npm run test

# Run E2E tests (starts backend automatically)
npm run test:e2e
```

### Development Environment

**Terminal 1 - Backend:**
```bash
cd backend
uv run uvicorn app.main:app --reload --port 8080
```

**Terminal 2 - Frontend:**
```bash
cd frontend
npm run dev
```

Access at http://localhost:5173 (frontend dev server proxies API requests to backend).

### Production Deployment

```bash
cd deployment
./deploy.sh
```

Access at http://localhost:6555
